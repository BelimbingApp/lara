#!/bin/bash
# Belimbing Configuration Variables
# Single source of truth for configuration defaults and helper functions
#
# === Configuration Variables ===
# These are loaded from .env file at runtime by start-app.sh
# and from storage/app/.devops/setup.env during setup steps.
#
# Expected variables:
# - APP_ENV: local|staging|production|testing
# - DATABASE_URL: PostgreSQL connection string
# - JWT_SECRET, JWT_EXPIRATION_HOURS, JWT_REFRESH_EXPIRATION_DAYS
# - FRONTEND_DOMAIN, BACKEND_DOMAIN
# - BACKEND_PORT, FRONTEND_PORT, HTTPS_PORT
# - SKIP_CADDY, PROXY_TYPE
# - BACKEND_URL

# === Setup Defaults ===
# shellcheck disable=SC2034
# Used by setup scripts to provide sensible defaults during interactive setup
DEFAULT_DB_USER="belimbing_app"
DEFAULT_DB_PASSWORD="v3ryL0ngP@55w0rd"
DEFAULT_DB_PORT="5432"
DEFAULT_PROXY_TYPE="caddy"
DEFAULT_SKIP_CADDY="false"

# Get default ports for an environment
get_default_ports() {
    local env=$1
    case "$env" in
        local)
            echo "3000|8080|443"
            ;;
        staging)
            echo "3001|8081|444"
            ;;
        production)
            echo "3002|8082|445"
            ;;
        testing)
            echo "3003|8083|446"
            ;;
        *)
            echo "3000|8080|443"
            ;;
    esac
}

# Get default domains for an environment
get_default_domains() {
    local env=$1
    echo "${env}.app.blb|${env}.api.blb"
}

# Get default JWT expiration values
get_default_jwt_expiration() {
    echo "24|30"
}

# Get default database name for an environment
get_default_database_name() {
    local env=$1
    echo "belimbing_${env}"
}

# === Environment Validation ===
# Normalize and validate APP_ENV variable
# Usage: normalize_and_validate_env "$APP_ENV"
# Returns: Normalized environment name (Laravel standard: local, staging, production, testing)
# Exits with code 1 if invalid
normalize_and_validate_env() {
    local env=$1

    # Normalize environment name (support old values for backward compatibility)
    case "$env" in
        dev|development) env="local" ;;
        stage) env="staging" ;;
        prod) env="production" ;;
        test) env="testing" ;;
    esac

    # Validate environment type (Laravel standard values)
    if [[ ! "$env" =~ ^(local|staging|production|testing)$ ]]; then
        echo -e "${RED}âœ—${NC} Invalid environment: $env" >&2
        echo -e "  Valid options: local, staging, production, testing" >&2
        exit 1
    fi

    echo "$env"
}

# === State Management ===
# Setup state file location
get_setup_state_file() {
    echo "$PROJECT_ROOT/storage/app/.devops/setup.env"
}

# Initialize setup state file with header if it doesn't exist
init_setup_state_file() {
    local state_file
    state_file=$(get_setup_state_file)

    if [ ! -f "$state_file" ]; then
        mkdir -p "$(dirname "$state_file")"
        cat > "$state_file" << 'EOF'
# Belimbing Setup State
# This file is generated by the setup scripts
# Do not edit manually - changes may be overwritten
EOF
    fi
}

# Load setup state from storage/app/.devops/setup.env
# Preserves CLI-provided APP_ENV if set before calling this function
# Automatically normalizes and validates APP_ENV after loading
load_setup_state() {
    local state_file
    state_file=$(get_setup_state_file)

    # Preserve CLI-provided APP_ENV (takes precedence over state files)
    local cli_app_env="${APP_ENV:-}"

    if [ -f "$state_file" ]; then
        # shellcheck disable=SC1090
        source "$state_file" 2>/dev/null || true
    fi

    # Also try loading from .env, make .env variables available
    if [ -f "$PROJECT_ROOT/.env" ]; then
        set -a
        source "$PROJECT_ROOT/.env" 2>/dev/null || true
        set +a
    fi

    # Restore CLI argument if it was set (CLI takes precedence)
    if [ -n "$cli_app_env" ]; then
        APP_ENV="$cli_app_env"
    fi

    # Normalize and validate APP_ENV (from CLI, state file, or .env)
    APP_ENV=$(normalize_and_validate_env "$APP_ENV")
}

# Save a key-value pair to setup state file
# Usage: save_to_setup_state "KEY" "value"
save_to_setup_state() {
    local key=$1
    local value=$2
    local state_file
    state_file=$(get_setup_state_file)

    # Ensure state file exists with header
    init_setup_state_file

    # Remove existing key if present
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "/^${key}=/d" "$state_file" 2>/dev/null || true
    else
        sed -i "/^${key}=/d" "$state_file" 2>/dev/null || true
    fi

    # Append new value
    echo "${key}=\"${value}\"" >> "$state_file"
}

# Update or add a variable to the .env file
# Usage: update_env_file "/path/to/.env" "VARIABLE_NAME" "value"
update_env_file() {
    local env_file=$1
    local var_name=$2
    local var_value=$3

    if [ ! -f "$env_file" ]; then
        echo "$var_name=\"$var_value\"" > "$env_file"
        return 0
    fi

    # Check if variable exists in file
    if grep -q "^${var_name}=" "$env_file"; then
        # Update existing variable (handle both quoted and unquoted values)
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS sed syntax
            sed -i '' "s|^${var_name}=.*|${var_name}=\"${var_value}\"|" "$env_file"
        else
            # Linux sed syntax
            sed -i "s|^${var_name}=.*|${var_name}=\"${var_value}\"|" "$env_file"
        fi
    else
        # Append new variable
        echo "$var_name=\"$var_value\"" >> "$env_file"
    fi
}
